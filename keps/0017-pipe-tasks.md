---
kep-number: 17
title: Pipe Tasks
authors:
  - "@zen-dog"
owners:
  - "@zen-dog"
editor: TBD
creation-date: 2019-09-12
last-updated: 2019-09-12
status: provisional
---

# Pipe Tasks

## Table of Contents

* [Table of Contents](#table-of-contents)
* [Summary](#summary)
* [Motivation](#motivation)
    * [Goals](#goals)
    * [Non-Goals](#non-goals)
* [Proposal](#proposal)
    * [Limitations](#limitations)
    * [Implementation Details/Notes/Constraints](#implementation-detailsnotesconstraints-optional)
* [Alternatives](#alternatives)

## Summary

Developing complicated operators often require generating files in one task and reusing them in a later one. A common example is generating custom certificates/dynamic configuration files in the bootstrap task and using them in the later deployment step of the service. This KEP describes how KUDO could help operator developers by making this task seamless and automated.

## Motivation

We want to ease the development of operators with complicated life-cycles by enabling to pipe files from one task to another. While this can be achieved in a manual way, involving custom scripts, this is exactly the kind of "magic glue" that KUDO could provide to the operator developers to ease the development process.

### Goals

The goal of this KEP is to describe application examples, limitations and ways to implement passing files between tasks. We aim to help operator developers pipe small files (<1Mb) like certificates and dynamically generated configuration which can be referenced later as ConfigMaps and Secrets.

### Non-Goals

Allowing to pipe all kind of files (>1Mb) between tasks requires a general-purpose storage solution (e.g. S3) available in the cluster. While certainly possible, this is not the goal of this KEP.

## Proposal

This section describes how pipe tasks and files they produce are configured in the operator. Here is a task definition that produces a file that will be stored as a Secret, referenced by `{{.Pipes.Certificate}}` key:
```yaml
steps:
    - name: bootstrap
    tasks:
        - gencert
            - pipe:
                - file: /usr/share/MyKey.key
                  kind: Secret # ConfigMap
                  key: {{.Pipes.Certificate}}
``` 
The key `{{.Pipes.Certificate}}` value will be generated by KUDO to avoid collisions and to make sure that it is not used before the file is generated. In the above example we would generate a secret name like `instance-myapp.deploy.bootstrap.gencert.pipes.certificate-#hash` to capture instance name along with plan/phase/step/task of the secret origin and the hash of its content. KUDO would use this hash to avoid recreating secrets for unchanged files on a plan rerun. We would also use labels ensuring that the secret is cleaned up when the corresponding Instance is removed.

The corresponding `gencert` task can only have one resource definition:
```yaml
tasks:
  gencert:
    resources:
      - gencert.yaml
```

For the pipe task resources, we only allow a [ContainerSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#container-v1-core) to be specified. Reasons for that are explained below in the implementation details. The ContainerSpec has to define a shared volume where the files are stored.

```yaml
spec:
  volumes:
  - name: shared-data
    emptyDir: {}

  containers:
    - name: gencert
      image: frapsoft/openssl
      imagePullPolicy: Always
      command: [ "sh", "-c" ]
      args:
        - openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out MyCertificate.crt -keyout /usr/share/MyKey.key
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/
```

Any subsequent step resource (if the phase strategy is `serial`) might reference previously generated file by its key `{{.Pipes.Certificate}}` e.g.:
```yaml
spec:
  containers:
  - name: myapp
    image: myapp:latest
    volumeMounts:
    - name: cert
      mountPath: /Ðµtc/certs
  volumes:
  - name: cert
    secret:
      secretName: {{.Pipes.Certificate}}
```

### Limitations
- File generating container has to be side-effect free (meaning side-effects that are observable outside of the container like a 3rd party API call) as the container might be executed multiple times on failure. If that's not the case, `restartPolicy: Never` has to be set which would prevent the task from finishing successfully.
- Only files <1Mb are applicable to be stored as ConfigMap or Secret.
- Only one resource per pipe task is allowed. If needed multiple tasks must be used.

### Implementation Details/Notes/Constraints

There are several ways to implement pipe tasks, each one having its challenges and complexities. The approach below allows us not to worry about Pod container life-cycle as well as keep the storing logic in the KUDO controller:
- Provided ContainerSpec is injected into a Pod as an [InitContainer](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/). This is the simplest way to wait for container completion. This is also the reason why pipe task resource definition is a ContainerSpec and not a complete Pod specification.
- The main container is a `busybox` image, running the `sleep infinity` command, which purpose is to wait for KUDO to extract and store the files.
- KUDO controller would copy referenced files from the Pod using `kubectl cp` and store them as specified.
- Once files are stored, KUDO can delete the Pod and proceed to the next task.

## Alternatives

An alternative approach would use the provided ContainerSpec as the main container (or let the user provide a complete Pod spec). We would inject a sidecar with a go executable which would:
- Use controller runtime, watch its own Pod status and wait for termination of the main container
- Once the main container exits, it would copy the referenced files and store them as specified
- We would use `restartPolicy: Never/OnFailure` to prevent the main container from restarting

While this approach would allow users to specify complete Pods as pipe task resources, a sidecar implementation would be an additional source of complexity and failure potential. The best code is no code at all.