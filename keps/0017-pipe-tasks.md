---
kep-number: 17
title: Pipe Tasks
short-desc: Feature for a mechanism that allows piping of resources (files) from one task to another
authors:
  - "@zen-dog"
owners:
  - "@zen-dog"
editor: TBD
creation-date: 2019-09-12
last-updated: 2019-09-12
status: provisional
---

# Pipe Tasks

## Table of Contents

* [Table of Contents](#table-of-contents)
* [Summary](#summary)
* [Motivation](#motivation)
    * [Goals](#goals)
    * [Non-Goals](#non-goals)
* [Proposal](#proposal)
    * [Limitations](#limitations)
    * [Implementation Details/Notes/Constraints](#implementation-detailsnotesconstraints-optional)
* [Alternatives](#alternatives)

## Summary

Developing complicated operators often require generating files in one task and reusing them in a later one. A common example is generating custom certificates/dynamic configuration files in the bootstrap task and using them in the later deployment step of the service. This KEP describes how KUDO could help operator developers by making this task seamless and automated.

## Motivation

We want to ease the development of operators with complicated life-cycles by enabling to pipe files from one task to another. While this can be achieved in a manual way, involving custom scripts, this is exactly the kind of "magic glue" that KUDO could provide to the operator developers to ease the development process.

### Goals

The goal of this KEP is to describe application examples, limitations and ways to implement passing files between tasks. We aim to help operator developers pipe small files (<1Mb) like certificates and dynamically generated configuration which can be referenced later as ConfigMaps and Secrets.

### Non-Goals

Allowing to pipe all kind of files (>1Mb) between tasks requires a general-purpose storage solution (e.g. S3) available in the cluster. While certainly possible, this is not the goal of this KEP.

## Proposal

This section describes how pipe tasks and files they produce are configured in the operator. Here is a task definition that produces a file that will be stored as a Secret, referenced by `{{.Pipes.Certificate}}` key:
```yaml
tasks:
  - name: gencert
    kind: Pipe
    spec:
      containerSpec:
        ...
      pipe:
        file: /usr/share/MyKey.key
        kind: Secret # ConfigMap
        key: {{.Pipes.Certificate}}
``` 

`containerSpec` field is described in detail below. `pipe` field defines how the produced file will be stored and referenced. The key `{{.Pipes.Certificate}}` value will be generated by KUDO to avoid collisions and to make sure that it is not used before the file is generated. In the above example we would generate a secret name like `instance-myapp.deploy.bootstrap.gencert.pipes.certificate-#hash` to capture instance name along with plan/phase/step/task of the secret origin and the hash of its content. KUDO would use this hash to avoid recreating secrets for unchanged files on a plan rerun. We would also use labels ensuring that the secret is cleaned up when the corresponding Instance is removed. 

The corresponding `gencert` task can be used as usual in e.g.:
```yaml
plans:
  deploy:
    strategy: serial
    phases:
     - name: bootstrap
       strategy: serial
       steps:
        - name: gencert
          tasks:
           - gencert
```

Note that piped files has to be generated before they can be used. In the example above, `bootstrap` phase has a strategy `serial` so that certificate generated in the `gencert` step can be used in subsequent steps. Or stated differently resources can not reference piped secrets/configmaps generated within the same step or within a parallel series of steps (it has to be a different step in the phase with serial strategy or a different phase). 

For the pipe task `containerSpec`, we allow a [ContainerSpec](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/#container-v1-core) to be specified. Reasons for that are explained below in the implementation details. The ContainerSpec has to define a shared volume where the files are stored.

```yaml
containerSpec:
  volumes:
  - name: shared-data
    emptyDir: {}

  containers:
    - name: gencert
      image: frapsoft/openssl
      imagePullPolicy: Always
      command: [ "sh", "-c" ]
      args:
        - openssl req -new -newkey rsa:4096 -x509 -sha256 -days 365 -nodes -out MyCertificate.crt -keyout /usr/share/MyKey.key
      volumeMounts:
        - name: shared-data
          mountPath: /usr/share/
```

Any subsequent step resource (if the phase strategy is `serial`) might reference previously generated file by its key `{{.Pipes.Certificate}}` e.g.:
```yaml
spec:
  containers:
  - name: myapp
    image: myapp:latest
    volumeMounts:
    - name: cert
      mountPath: /Ðµtc/certs
  volumes:
  - name: cert
    secret:
      secretName: {{.Pipes.Certificate}}
```

### Limitations
- File generating container has to be side-effect free (meaning side-effects that are observable outside of the container like a 3rd party API call) as the container might be executed multiple times on failure. If that's not the case, `restartPolicy: Never` has to be set which would prevent the task from finishing successfully.
- Only files <1Mb are applicable to be stored as ConfigMap or Secret.
- Only one resource per pipe task is allowed. If needed multiple tasks must be used.

### Implementation Details/Notes/Constraints

There are several ways to implement pipe tasks, each one having its challenges and complexities. The approach below allows us not to worry about Pod container life-cycle as well as keep the storing logic in the KUDO controller:
- Provided ContainerSpec is injected into a Pod as an [InitContainer](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/). This is the simplest way to wait for container completion. This is also the reason why pipe task resource definition is a ContainerSpec and not a complete Pod specification. Pod init container can not have Lifecycle actions, Readiness probes, or Liveness probes fields defined. 
- The main container is a `busybox` image, running the `sleep infinity` command, which purpose is to wait for KUDO to extract and store the files.
- Pod status `READY: 1/1, STATUS: Running` means that the init container has run successfully. As this point KUDO can copy out referenced files using `kubectl cp` and store them as specified.
- Once files are stored, KUDO can delete the Pod and proceed to the next task.

Here is a minimal example demonstrating the proposed implementation:
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: pipe-task
spec:
  volumes:
  - name: shared-data
    emptyDir: {}

  # Inject provided ContainerSpec generating /tmp/foo.txt
  initContainers:
    - name: init
      image: busybox
      command: [ "/bin/sh", "-c" ]
      args:
        - echo "foo-bar-bazz" > /tmp/foo.txt
      volumeMounts:
        - name: shared-data
          mountPath: /tmp

  # Wait for KUDO controller to copy out the file
  containers:
    - name: sleep
      image: busybox
      command: [ "/bin/sh", "-c" ]
      args: [ "sleep infinity" ]
      volumeMounts:
        - name: shared-data
          mountPath: /tmp
  restartPolicy: OnFailure
```

The generated file can be copied out of the Pod with:
```bash
$ kubectl cp default/pipe-task:/tmp/foo.txt /dev/stdout
foo-bar-bazz
```

## Alternatives

An alternative approach would use the provided ContainerSpec as the main container (or let the user provide a complete Pod spec). We would inject a sidecar with a go executable which would:
- Use controller runtime, watch its own Pod status and wait for termination of the main container
- Once the main container exits, it would copy the referenced files and store them as specified
- We would use `restartPolicy: Never/OnFailure` to prevent the main container from restarting

While this approach would allow users to specify complete Pods as pipe task resources, a sidecar implementation would be an additional source of complexity and failure potential. The best code is no code at all.
